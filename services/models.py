from django.contrib.auth import get_user_model
from django.db import models

from accounts.models import City, County, CraftsmanProfile
from notifications.services import NotificationService

User = get_user_model()


class ServiceCategory(models.Model):
    name = models.CharField(max_length=100, unique=True)
    slug = models.SlugField(unique=True)
    icon = models.CharField(max_length=50, blank=True, help_text="CSS class pentru icon")
    icon_emoji = models.CharField(max_length=8, default="游댢", help_text="Emoji icon for category")
    description = models.TextField(max_length=500, blank=True)
    is_active = models.BooleanField(default=True)
    order = models.PositiveIntegerField(default=0)

    class Meta:
        ordering = ["order", "name"]
        verbose_name_plural = "Service Categories"

    def __str__(self):
        return self.name


class Service(models.Model):
    category = models.ForeignKey(ServiceCategory, on_delete=models.CASCADE, related_name="services")
    name = models.CharField(max_length=200)
    slug = models.SlugField(unique=True)  # Changed to unique for easier lookup
    description = models.TextField(max_length=500, blank=True)
    is_popular = models.BooleanField(default=False, help_text="Popular service shown in suggestions")
    is_active = models.BooleanField(default=True)

    class Meta:
        ordering = ["name"]

    def __str__(self):
        return f"{self.category.name} - {self.name}"


class CraftsmanService(models.Model):
    craftsman = models.ForeignKey(CraftsmanProfile, on_delete=models.CASCADE, related_name="services")
    service = models.ForeignKey(Service, on_delete=models.CASCADE)
    price_from = models.DecimalField(max_digits=8, decimal_places=2, null=True, blank=True)
    price_to = models.DecimalField(max_digits=8, decimal_places=2, null=True, blank=True)
    price_unit = models.CharField(max_length=50, blank=True, help_text="ex: per or캒, per mp, per bucat캒")

    class Meta:
        unique_together = ["craftsman", "service"]

    def __str__(self):
        return f"{self.craftsman.user.username} - {self.service.name}"


class Order(models.Model):
    STATUS_CHOICES = [
        ("draft", "Ciorn캒"),
        ("published", "Publicat캒"),
        ("awaiting_confirmation", "A탳teapt캒 confirmarea me탳terului"),
        ("in_progress", "칉n progres"),
        ("completed", "Finalizat캒"),
        ("cancelled", "Anulat캒"),
    ]

    # Status groups for robust filtering
    COMPLETED_STATUSES = ["completed"]
    CANCELLED_STATUSES = ["cancelled"]
    ACTIVE_STATUSES = ["published", "awaiting_confirmation", "in_progress"]

    URGENCY_CHOICES = [
        ("low", "Nu este urgent"),
        ("medium", "칉n urm캒toarele s캒pt캒m칙ni"),
        ("high", "칉n urm캒toarele zile"),
        ("urgent", "Urgent"),
    ]

    # Basic info
    client = models.ForeignKey(User, on_delete=models.CASCADE, related_name="orders")
    title = models.CharField(max_length=200)
    description = models.TextField(max_length=2000)
    service = models.ForeignKey(Service, on_delete=models.CASCADE)

    # Location
    county = models.ForeignKey(County, on_delete=models.CASCADE)
    city = models.ForeignKey(City, on_delete=models.CASCADE)
    address = models.CharField(max_length=300, blank=True)

    # Details
    budget_min = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    budget_max = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    urgency = models.CharField(max_length=10, choices=URGENCY_CHOICES, default="medium")
    preferred_date = models.DateField(null=True, blank=True)

    # Status
    status = models.CharField(max_length=25, choices=STATUS_CHOICES, default="draft")
    assigned_craftsman = models.ForeignKey(
        CraftsmanProfile, on_delete=models.SET_NULL, null=True, blank=True, related_name="assigned_orders"
    )

    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    published_at = models.DateTimeField(null=True, blank=True)
    selected_at = models.DateTimeField(null=True, blank=True, help_text="C칙nd clientul a selectat me탳terul")
    confirmed_at = models.DateTimeField(null=True, blank=True, help_text="C칙nd me탳terul a confirmat preluarea")

    class Meta:
        ordering = ["-created_at"]

    def __str__(self):
        return f"{self.title} - {self.client.username}"


class OrderImage(models.Model):
    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name="images")
    image = models.ImageField(upload_to="order_images/")
    description = models.CharField(max_length=200, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.order.title} - Image"


class Quote(models.Model):
    STATUS_CHOICES = [
        ("pending", "칉n a탳teptare"),
        ("accepted", "Acceptat캒"),
        ("rejected", "Respins캒"),
        ("declined", "Refuzat캒 de me탳ter"),
        ("expired", "Expirat캒"),
    ]

    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name="quotes")
    craftsman = models.ForeignKey(CraftsmanProfile, on_delete=models.CASCADE, related_name="quotes")

    price = models.DecimalField(max_digits=10, decimal_places=2)
    description = models.TextField(max_length=1000)

    # Duration fields - structured data
    duration_value = models.IntegerField(
        null=True,
        blank=True,
        verbose_name="Valoare durat캒",
        help_text="Num캒rul de unit캒탵i de timp (ex: 5 pentru '5 zile')"
    )
    duration_unit = models.CharField(
        max_length=20,
        null=True,
        blank=True,
        choices=[
            ('hours', 'Ore'),
            ('days', 'Zile'),
            ('weeks', 'S캒pt캒m칙ni'),
            ('months', 'Luni'),
        ],
        verbose_name="Unitate durat캒",
        help_text="Unitatea de m캒sur캒 pentru durat캒"
    )

    # Keep for backwards compatibility & display
    estimated_duration = models.CharField(max_length=100, blank=True)

    proposed_start_date = models.DateField(
        null=True,
        blank=True,
        verbose_name="Data propus캒 pornire",
        help_text="Data la care me탳terul propune s캒 칥nceap캒 lucrarea"
    )

    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default="pending")

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    expires_at = models.DateTimeField()

    class Meta:
        ordering = ["-created_at"]
        unique_together = ["order", "craftsman"]

    def __str__(self):
        return f"Ofert캒 pentru {self.order.title} de la {self.craftsman.user.username}"

    def save(self, *args, **kwargs):
        """Auto-generate estimated_duration from duration_value + duration_unit"""
        if self.duration_value and self.duration_unit:
            # Romanian plural forms
            unit_map = {
                'hours': 'or캒' if self.duration_value == 1 else 'ore',
                'days': 'zi' if self.duration_value == 1 else 'zile',
                'weeks': 's캒pt캒m칙n캒' if self.duration_value == 1 else 's캒pt캒m칙ni',
                'months': 'lun캒' if self.duration_value == 1 else 'luni',
            }
            self.estimated_duration = f"{self.duration_value} {unit_map[self.duration_unit]}"
        super().save(*args, **kwargs)


class QuoteAttachment(models.Model):
    """Ata탳amente pentru oferte (imagini, PDF-uri, documente)"""

    quote = models.ForeignKey(Quote, on_delete=models.CASCADE, related_name="attachments")
    file = models.FileField(upload_to="quote_attachments/%Y/%m/")

    FILE_TYPE_CHOICES = [
        ("image", "Imagine"),
        ("pdf", "PDF"),
        ("document", "Document"),
        ("other", "Altele"),
    ]
    file_type = models.CharField(max_length=20, choices=FILE_TYPE_CHOICES)
    file_size = models.PositiveIntegerField(help_text="M캒rime fi탳ier 칥n bytes")

    description = models.CharField(max_length=200, blank=True, help_text="Descriere scurt캒 (op탵ional)")
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["created_at"]
        verbose_name = "Ata탳ament Ofert캒"
        verbose_name_plural = "Ata탳amente Oferte"

    def __str__(self):
        return f"Ata탳ament {self.file_type} - {self.quote}"

    @property
    def file_size_mb(self):
        """Returneaz캒 m캒rimea fi탳ierului 칥n MB"""
        return round(self.file_size / (1024 * 1024), 2)

    @property
    def filename(self):
        """Returneaz캒 numele fi탳ierului f캒r캒 path"""
        import os
        return os.path.basename(self.file.name)


class Review(models.Model):
    order = models.OneToOneField(Order, on_delete=models.SET_NULL, null=True, blank=True, related_name="review")
    client = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True, related_name="given_reviews")
    craftsman = models.ForeignKey(CraftsmanProfile, on_delete=models.CASCADE, related_name="received_reviews")

    rating = models.PositiveIntegerField(choices=[(i, i) for i in range(1, 6)])  # 1-5 stars
    comment = models.TextField(max_length=1000, blank=True)

    # Detailed ratings
    quality_rating = models.PositiveIntegerField(choices=[(i, i) for i in range(1, 6)], null=True, blank=True)
    punctuality_rating = models.PositiveIntegerField(choices=[(i, i) for i in range(1, 6)], null=True, blank=True)
    communication_rating = models.PositiveIntegerField(choices=[(i, i) for i in range(1, 6)], null=True, blank=True)

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["-created_at"]

    def __str__(self):
        return f"Review pentru {self.craftsman.user.username} - {self.rating} stele"


class ReviewImage(models.Model):
    review = models.ForeignKey(Review, on_delete=models.CASCADE, related_name="images")
    image = models.ImageField(upload_to="review_images/")
    description = models.CharField(max_length=200, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Review Image - {self.review.craftsman.user.username}"


# Notification helper functions
def notify_new_quote(quote):
    """Notify client about new quote using centralized NotificationService"""
    return NotificationService().create_notification(
        recipient=quote.order.client,
        title=f'Ofert캒 nou캒 pentru "{quote.order.title}"',
        message=(
            f"{quote.craftsman.user.get_full_name() or quote.craftsman.user.username} "
            f"a trimis o ofert캒 de {quote.price} RON."
        ),
        notification_type="new_quote",
        priority="high",
        sender=quote.craftsman.user,
        action_url=f"/servicii/comanda/{quote.order.id}/",
        related_object_type="quote",
        related_object_id=quote.id,
        data={"order_id": quote.order.id, "quote_id": quote.id, "price": float(quote.price)},
    )


def notify_quote_accepted(quote):
    """Notify craftsman about accepted quote using centralized NotificationService"""
    return NotificationService().create_notification(
        recipient=quote.craftsman.user,
        title="Oferta ta a fost acceptat캒!",
        message=(
            f'Clientul a acceptat oferta ta pentru "{quote.order.title}". '
            "Te rug캒m s캒 confirmi c캒 po탵i prelua aceast캒 comand캒."
        ),
        notification_type="quote_accepted",
        priority="high",
        action_url=f"/servicii/comanda/{quote.order.id}/",
        related_object_type="quote",
        related_object_id=quote.id,
        data={"order_id": quote.order.id, "quote_id": quote.id},
    )


def notify_quote_rejected(quote):
    """Notify craftsman about rejected quote using centralized NotificationService"""
    return NotificationService().create_notification(
        recipient=quote.craftsman.user,
        title="Oferta ta a fost respins캒",
        message=(f'Din p캒cate, oferta ta pentru "{quote.order.title}" nu a fost acceptat캒.'),
        notification_type="quote_rejected",
        priority="medium",
        action_url=f"/servicii/comanda/{quote.order.id}/",
        related_object_type="quote",
        related_object_id=quote.id,
        data={"order_id": quote.order.id, "quote_id": quote.id},
    )


def notify_order_request(order, craftsman):
    """Notify craftsman about new personal/direct order request using NotificationService"""
    return NotificationService().create_notification(
        recipient=craftsman.user,
        notification_type="personal_order",
        title="Solicitare personal캒 de ofert캒",
        message=(
            f'Ai primit o solicitare personal캒 de ofert캒 pentru "{order.title}" 칥n '
            f"{order.city.name}, {order.county.name}. Clientul {order.client.get_full_name() or order.client.username} "
            "te-a ales special pentru aceast캒 lucrare!"
        ),
        priority="high",
        sender=order.client,
        action_url=f"/servicii/comanda/{order.id}/",
        related_object_type="order",
        related_object_id=order.id,
        data={"order_id": order.id, "is_personal_request": True, "invited_craftsman_id": craftsman.user.id},
    )


def notify_new_order_to_craftsmen(order):
    """
    Notify all craftsmen who have the order's service registered that a new order is available.

    Professional notification system that:
    - Filters craftsmen by registered matching service
    - Excludes craftsmen who already quoted on this order
    - Respects user notification preferences
    - Priority-based delivery: urgent orders get email + push, others get push only
    - Limits to maximum 50 craftsmen to avoid spam

    Args:
        order: Order instance that was just published

    Returns:
        int: Number of notifications successfully sent
    """
    import logging
    logger = logging.getLogger(__name__)

    # Get all craftsmen who have this service registered
    craftsmen_with_service = CraftsmanProfile.objects.filter(
        services__service=order.service,
        user__is_active=True
    ).select_related('user').distinct()

    # Exclude craftsmen who already quoted on this order
    craftsmen_who_quoted = Quote.objects.filter(
        order=order
    ).values_list('craftsman_id', flat=True)

    eligible_craftsmen = craftsmen_with_service.exclude(
        id__in=craftsmen_who_quoted
    )[:50]  # Limit to 50 to avoid overwhelming the system

    if not eligible_craftsmen.exists():
        logger.info(f"No eligible craftsmen to notify for order {order.id}")
        return 0

    # Determine notification priority based on order urgency
    is_urgent = order.urgency in ['urgent', 'high']
    priority = "urgent" if is_urgent else "normal"

    # Prepare notification content
    budget_text = ""
    if order.budget_min and order.budget_max:
        budget_text = f" Buget: {order.budget_min}-{order.budget_max} RON."
    elif order.budget_max:
        budget_text = f" Buget: p칙n캒 la {order.budget_max} RON."

    urgency_text = {
        'urgent': ' URGENT!',
        'high': ' (칉n urm캒toarele zile)',
        'medium': '',
        'low': ''
    }.get(order.urgency, '')

    title = f"Comand캒 nou캒: {order.service.name}{urgency_text}"
    message = (
        f'Comand캒 nou캒 칥n {order.city.name}, {order.county.name}: "{order.title}".{budget_text} '
        f'Click pentru a vedea detalii 탳i a trimite ofert캒!'
    )

    # Send notifications
    notifications_sent = 0
    for craftsman in eligible_craftsmen:
        try:
            NotificationService.create_notification(
                recipient=craftsman.user,
                title=title,
                message=message,
                notification_type="new_order",
                priority=priority,
                sender=None,  # System notification
                action_url=f"/servicii/comanda/{order.id}/",
                related_object_type="order",
                related_object_id=order.id,
                send_email=is_urgent,  # Only send email for urgent/high urgency orders
                send_push=True,  # Always send push notification
                data={
                    "order_id": order.id,
                    "service_id": order.service.id,
                    "service_name": order.service.name,
                    "location": f"{order.city.name}, {order.county.name}",
                    "urgency": order.urgency
                }
            )
            notifications_sent += 1
        except Exception as e:
            logger.error(f"Failed to notify craftsman {craftsman.user.id} about order {order.id}: {str(e)}")
            continue

    logger.info(f"Notified {notifications_sent} craftsmen about new order {order.id}")
    return notifications_sent


# MyBuilder-style Lead System Models


class Invitation(models.Model):
    """Invita탵ii trimise de clien탵i c캒tre me탳teri pentru a oferta"""

    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name="invitations")
    craftsman = models.ForeignKey("accounts.User", on_delete=models.CASCADE, related_name="invitations")
    invited_by = models.ForeignKey("accounts.User", on_delete=models.CASCADE, related_name="sent_invitations")

    STATUS_CHOICES = [
        ("pending", "칉n a탳teptare"),
        ("accepted", "Acceptat캒"),
        ("declined", "Refuzat캒"),
    ]
    status = models.CharField(max_length=12, choices=STATUS_CHOICES, default="pending")
    created_at = models.DateTimeField(auto_now_add=True)
    responded_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        unique_together = [("order", "craftsman")]
        ordering = ["-created_at"]

    def __str__(self):
        return f"Invita탵ie pentru {self.craftsman.get_full_name()} - {self.order.title}"


class Shortlist(models.Model):
    """Shortlisting MyBuilder-style - clientul alege me탳terii cu care vrea s캒 vorbeasc캒"""

    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name="shortlists")
    craftsman = models.ForeignKey("accounts.User", on_delete=models.CASCADE, related_name="shortlisted_for")

    # Lead fee system
    lead_fee_amount = models.PositiveIntegerField(default=0, help_text="Taxa 칥n bani (cents)")
    charged_at = models.DateTimeField(null=True, blank=True, help_text="C칙nd s-a deductat taxa")
    revealed_contact_at = models.DateTimeField(null=True, blank=True, help_text="C칙nd s-au afi탳at datele de contact")

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = [("order", "craftsman")]
        ordering = ["-created_at"]

    def __str__(self):
        return f"Shortlist: {self.craftsman.get_full_name()} pentru {self.order.title}"

    @property
    def lead_fee_lei(self):
        """Returneaz캒 taxa 칥n lei"""
        return self.lead_fee_amount / 100

    @property
    def is_contact_revealed(self):
        """Verific캒 dac캒 contactul a fost deblocat - MODIFICAT: contactele sunt 칥ntotdeauna vizibile"""
        return True  # Contactele sunt 칥ntotdeauna vizibile


# REMOVED: CreditWallet and WalletTransaction models
# Wallet system removed in favor of subscription-based model
# All wallet data exported to CSV before removal (see subscriptions/management/commands/export_wallet_data.py)
# Transition date: 2025-10-18
# Migration: subscriptions/migrations/00XX_remove_wallet_system.py


class CoverageArea(models.Model):
    """Zona de acoperire geografic캒 pentru me탳teri"""

    profile = models.OneToOneField("accounts.CraftsmanProfile", on_delete=models.CASCADE, related_name="coverage")
    base_city = models.ForeignKey("accounts.City", on_delete=models.PROTECT, help_text="Ora탳ul de baz캒")
    radius_km = models.PositiveSmallIntegerField(default=30, help_text="Raza de acoperire 칥n km")

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.profile.user.get_full_name()} - {self.base_city.name} ({self.radius_km}km)"

    class Meta:
        verbose_name = "Zon캒 de acoperire"
        verbose_name_plural = "Zone de acoperire"


# Helper functions for Quote Attachments
def validate_quote_attachment(file):
    """Valideaz캒 tipul 탳i m캒rimea fi탳ierului pentru ata탳amente oferte"""
    import os
    from django.core.exceptions import ValidationError

    # Check file size (max 5MB)
    max_size = 5 * 1024 * 1024  # 5MB in bytes
    if file.size > max_size:
        raise ValidationError(f"Fi탳ierul este prea mare ({file.size / (1024 * 1024):.1f}MB). M캒rimea maxim캒 permis캒 este 5MB.")

    # Check file extension
    allowed_extensions = [".jpg", ".jpeg", ".png", ".gif", ".pdf", ".doc", ".docx"]
    ext = os.path.splitext(file.name)[1].lower()
    if ext not in allowed_extensions:
        raise ValidationError(
            f"Tip fi탳ier nepermis ({ext}). Tipuri permise: {', '.join(allowed_extensions)}"
        )

    return file


def detect_file_type(file):
    """Detecteaz캒 tipul fi탳ierului bazat pe extensie"""
    import os

    ext = os.path.splitext(file.name)[1].lower()
    if ext in [".jpg", ".jpeg", ".png", ".gif"]:
        return "image"
    elif ext == ".pdf":
        return "pdf"
    elif ext in [".doc", ".docx"]:
        return "document"
    else:
        return "other"
